{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Graphene Django Query Optimizer pip install graphene-django-query-optimizer Documentation : https://mrthearman.github.io/graphene-django-query-optimizer/ Source Code : https://github.com/MrThearMan/graphene-django-query-optimizer/ Contributing : https://github.com/MrThearMan/graphene-django-query-optimizer/blob/main/CONTRIBUTING.md Solve the GraphQL N+1 problem in graphene-django applications just by changing a few imports, automatically adding the appropriate only , select_related , and prefetch_related method calls to your QuerySets to fetch only what you need. import graphene from graphene_django import DjangoListField from example import ExampleModel # from graphene_django import DjangoObjectType # old import from query_optimizer import DjangoObjectType # new import class ExampleType(DjangoObjectType): class Meta: model = ExampleModel class Query(graphene.ObjectType): all_examples = DjangoListField(ExampleType) schema = graphene.Schema(query=Query)","title":"Home"},{"location":"#graphene-django-query-optimizer","text":"pip install graphene-django-query-optimizer Documentation : https://mrthearman.github.io/graphene-django-query-optimizer/ Source Code : https://github.com/MrThearMan/graphene-django-query-optimizer/ Contributing : https://github.com/MrThearMan/graphene-django-query-optimizer/blob/main/CONTRIBUTING.md Solve the GraphQL N+1 problem in graphene-django applications just by changing a few imports, automatically adding the appropriate only , select_related , and prefetch_related method calls to your QuerySets to fetch only what you need. import graphene from graphene_django import DjangoListField from example import ExampleModel # from graphene_django import DjangoObjectType # old import from query_optimizer import DjangoObjectType # new import class ExampleType(DjangoObjectType): class Meta: model = ExampleModel class Query(graphene.ObjectType): all_examples = DjangoListField(ExampleType) schema = graphene.Schema(query=Query)","title":"Graphene Django Query Optimizer"},{"location":"custom/","text":"Custom fields GraphQL types can have non-model fields using custom resolvers. import graphene from query_optimizer import DjangoObjectType from query_optimizer.typing import GQLInfo from tests.example.models import HousingCompany class HousingCompanyType(DjangoObjectType): class Meta: model = HousingCompany greeting = graphene.String() def resolve_greeting(model: HousingCompany, info: GQLInfo) -> str: return f\"Hello World!\" If the custom type requires fields from its related models to resolve, you can use the included required_fields decorator to make sure they are fetched from the database. import graphene from query_optimizer import DjangoObjectType, required_fields # new import from query_optimizer.typing import GQLInfo from tests.example.models import HousingCompany class HousingCompanyType(DjangoObjectType): class Meta: model = HousingCompany greeting = graphene.String() manager = graphene.String() primary_real_estate = graphene.String() @required_fields(\"name\") # fetched def resolve_greeting(model: HousingCompany, info: GQLInfo) -> str: return f\"Hello {model.name}!\" @required_fields(\"property_manager__name\") # selected def resolve_manager(model: HousingCompany, info: GQLInfo) -> str: return model.property_manager.name @required_fields(\"real_estates__name\") # prefetched def resolve_primary_real_estate(model: HousingCompany, info: GQLInfo) -> str: return model.real_estates.first().name","title":"Custom Fields"},{"location":"custom/#custom-fields","text":"GraphQL types can have non-model fields using custom resolvers. import graphene from query_optimizer import DjangoObjectType from query_optimizer.typing import GQLInfo from tests.example.models import HousingCompany class HousingCompanyType(DjangoObjectType): class Meta: model = HousingCompany greeting = graphene.String() def resolve_greeting(model: HousingCompany, info: GQLInfo) -> str: return f\"Hello World!\" If the custom type requires fields from its related models to resolve, you can use the included required_fields decorator to make sure they are fetched from the database. import graphene from query_optimizer import DjangoObjectType, required_fields # new import from query_optimizer.typing import GQLInfo from tests.example.models import HousingCompany class HousingCompanyType(DjangoObjectType): class Meta: model = HousingCompany greeting = graphene.String() manager = graphene.String() primary_real_estate = graphene.String() @required_fields(\"name\") # fetched def resolve_greeting(model: HousingCompany, info: GQLInfo) -> str: return f\"Hello {model.name}!\" @required_fields(\"property_manager__name\") # selected def resolve_manager(model: HousingCompany, info: GQLInfo) -> str: return model.property_manager.name @required_fields(\"real_estates__name\") # prefetched def resolve_primary_real_estate(model: HousingCompany, info: GQLInfo) -> str: return model.real_estates.first().name","title":"Custom fields"},{"location":"depth/","text":"Depth Limiting The optimize() function has builtin query depth limiting, which will allow a maximum of 10 select_related and prefetch_related actions per query by default. This should be a sensible limit that protects your API from misuse, but if you need to change it, it can be done on per resolver basis: import graphene from query_optimizer import DjangoObjectType, optimize from tests.example.models import Apartment class ApartmentType(DjangoObjectType): class Meta: model = Apartment class Query(graphene.ObjectType): all_apartments = graphene.List(ApartmentType) def resolve_all_apartments(root, info): return optimize(Apartment.objects.all(), info, max_complexity=4) # changed schema = graphene.Schema(query=Query) ...or per ObjectType basis for relay nodes and connections. import graphene from graphene import relay from query_optimizer import DjangoObjectType from tests.example.models import Apartment class ApartmentNode(DjangoObjectType): class Meta: model = Apartment interfaces = (relay.Node,) max_complexity = 4 # changed class Query(graphene.ObjectType): apartment = relay.Node.Field(ApartmentNode) schema = graphene.Schema(query=Query) You can also set the MAX_COMPLEXITY setting in your project's settings.py to set the value for all optimizers: GRAPHQL_QUERY_OPTIMIZER = { \"MAX_COMPLEXITY\": 15, }","title":"Depth Limiting"},{"location":"depth/#depth-limiting","text":"The optimize() function has builtin query depth limiting, which will allow a maximum of 10 select_related and prefetch_related actions per query by default. This should be a sensible limit that protects your API from misuse, but if you need to change it, it can be done on per resolver basis: import graphene from query_optimizer import DjangoObjectType, optimize from tests.example.models import Apartment class ApartmentType(DjangoObjectType): class Meta: model = Apartment class Query(graphene.ObjectType): all_apartments = graphene.List(ApartmentType) def resolve_all_apartments(root, info): return optimize(Apartment.objects.all(), info, max_complexity=4) # changed schema = graphene.Schema(query=Query) ...or per ObjectType basis for relay nodes and connections. import graphene from graphene import relay from query_optimizer import DjangoObjectType from tests.example.models import Apartment class ApartmentNode(DjangoObjectType): class Meta: model = Apartment interfaces = (relay.Node,) max_complexity = 4 # changed class Query(graphene.ObjectType): apartment = relay.Node.Field(ApartmentNode) schema = graphene.Schema(query=Query) You can also set the MAX_COMPLEXITY setting in your project's settings.py to set the value for all optimizers: GRAPHQL_QUERY_OPTIMIZER = { \"MAX_COMPLEXITY\": 15, }","title":"Depth Limiting"},{"location":"fragments/","text":"Fragments Fragment spreads Example query: query { allApartments { ...Shares } } fragment Shares on ApartmentType { sharesStart sharesEnd } Fragments spreads like these are optimized without any additional setup. Inline fragments Example query: query { allPeople { ... on DeveloperType { name housingCompanies { name } __typename } ... on PropertyManagerType { name housingCompanies { name } __typename } ... on OwnerType { name ownerships { percentage } __typename } } } Inline fragments like these can also be optimized. Here is how you would construct a resolver like this: import itertools import graphene from query_optimizer import DjangoObjectType, optimize from tests.example.models import Developer, PropertyManager, Owner class DeveloperType(DjangoObjectType): class Meta: model = Developer class PropertyManagerType(DjangoObjectType): class Meta: model = PropertyManager class OwnerType(DjangoObjectType): class Meta: model = Owner class People(graphene.Union): class Meta: types = ( DeveloperType, PropertyManagerType, OwnerType, ) class Query(graphene.ObjectType): all_people = graphene.List(People) def resolve_all_people(parent, info): developers = optimize(Developer.objects.all(), info) property_managers = optimize(PropertyManager.objects.all(), info) owners = optimize(Owner.objects.all(), info) return itertools.chain(developers, property_managers, owners) schema = graphene.Schema(query=Query)","title":"Fragments"},{"location":"fragments/#fragments","text":"","title":"Fragments"},{"location":"fragments/#fragment-spreads","text":"Example query: query { allApartments { ...Shares } } fragment Shares on ApartmentType { sharesStart sharesEnd } Fragments spreads like these are optimized without any additional setup.","title":"Fragment spreads"},{"location":"fragments/#inline-fragments","text":"Example query: query { allPeople { ... on DeveloperType { name housingCompanies { name } __typename } ... on PropertyManagerType { name housingCompanies { name } __typename } ... on OwnerType { name ownerships { percentage } __typename } } } Inline fragments like these can also be optimized. Here is how you would construct a resolver like this: import itertools import graphene from query_optimizer import DjangoObjectType, optimize from tests.example.models import Developer, PropertyManager, Owner class DeveloperType(DjangoObjectType): class Meta: model = Developer class PropertyManagerType(DjangoObjectType): class Meta: model = PropertyManager class OwnerType(DjangoObjectType): class Meta: model = Owner class People(graphene.Union): class Meta: types = ( DeveloperType, PropertyManagerType, OwnerType, ) class Query(graphene.ObjectType): all_people = graphene.List(People) def resolve_all_people(parent, info): developers = optimize(Developer.objects.all(), info) property_managers = optimize(PropertyManager.objects.all(), info) owners = optimize(Owner.objects.all(), info) return itertools.chain(developers, property_managers, owners) schema = graphene.Schema(query=Query)","title":"Inline fragments"},{"location":"quickstart/","text":"Quickstart The database schema these examples will be using can be seen here . Let's say we have defined a graphql schema like this: import graphene from graphene_django import DjangoObjectType, DjangoListField from tests.example.models import Apartment class ApartmentType(DjangoObjectType): class Meta: model = Apartment class Query(graphene.ObjectType): # Imagine the rest of the types are also here, # and we omit it for brevity. all_apartments = DjangoListField(ApartmentType) schema = graphene.Schema(query=Query) Now, based on our database schema, we want to make a query like this: query { allApartments { streetAddress stair apartmentNumber sales { purchaseDate ownerships { percentage owner { name } } } } } As is, this query will result in: 1 query for all apartments 1 query or each sale 1 query for each ownership in each sale 1 query for each owner in each ownership in each sale Let's say that we have: a modest 20 apartments each apartment has 3 sales each sale has 2 ownerships In total, that's... 1 + (20 * 3) + (20 * 3 * 2) + (20 * 3 * 2 * 1) = 301 queries It's important to notice, that the amount of queries is proportional to the amount of records in our database, so the number of queries is only going to increase. This is called an N+1 problem . We are also over-fetching all fields on each model, and thus not taking advantage of GraphQLs schema at all. This is the issue this library hopes to solve. Shoutout to graphene-django-optimizer , which inspired this library. The library seem to no longer work in modern versions of graphene-django . Hopefully this library can replace it, while offering a cleaner API. We can optimize this query by simply using DjangoObjectType from query_optimizer instead of graphene_django import graphene from graphene_django import DjangoListField from query_optimizer import DjangoObjectType # new import from tests.example.models import Apartment class ApartmentType(DjangoObjectType): class Meta: model = Apartment class Query(graphene.ObjectType): all_apartments = DjangoListField(ApartmentType) schema = graphene.Schema(query=Query) We could also use the optimize function to wrap a custom resolver queryset: import graphene from query_optimizer import DjangoObjectType, optimize # new import from tests.example.models import Apartment class ApartmentType(DjangoObjectType): class Meta: model = Apartment class Query(graphene.ObjectType): all_apartments = graphene.List(ApartmentType) def resolve_all_apartments(root, info): return optimize(Apartment.objects.all(), info) # wrapped function schema = graphene.Schema(query=Query) That's it! With the following configuration, the same query will result in just 3 database queries, regardless of the number of database records. 1 query for all apartments 1 query for all sales in all apartments 1 query for all ownerships with their owners for each sale in each apartment Also, the optimization will only fetch the fields given in the GraphQL query, as the query intended. See technical details on how this works.","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"The database schema these examples will be using can be seen here . Let's say we have defined a graphql schema like this: import graphene from graphene_django import DjangoObjectType, DjangoListField from tests.example.models import Apartment class ApartmentType(DjangoObjectType): class Meta: model = Apartment class Query(graphene.ObjectType): # Imagine the rest of the types are also here, # and we omit it for brevity. all_apartments = DjangoListField(ApartmentType) schema = graphene.Schema(query=Query) Now, based on our database schema, we want to make a query like this: query { allApartments { streetAddress stair apartmentNumber sales { purchaseDate ownerships { percentage owner { name } } } } } As is, this query will result in: 1 query for all apartments 1 query or each sale 1 query for each ownership in each sale 1 query for each owner in each ownership in each sale Let's say that we have: a modest 20 apartments each apartment has 3 sales each sale has 2 ownerships In total, that's... 1 + (20 * 3) + (20 * 3 * 2) + (20 * 3 * 2 * 1) = 301 queries It's important to notice, that the amount of queries is proportional to the amount of records in our database, so the number of queries is only going to increase. This is called an N+1 problem . We are also over-fetching all fields on each model, and thus not taking advantage of GraphQLs schema at all. This is the issue this library hopes to solve. Shoutout to graphene-django-optimizer , which inspired this library. The library seem to no longer work in modern versions of graphene-django . Hopefully this library can replace it, while offering a cleaner API. We can optimize this query by simply using DjangoObjectType from query_optimizer instead of graphene_django import graphene from graphene_django import DjangoListField from query_optimizer import DjangoObjectType # new import from tests.example.models import Apartment class ApartmentType(DjangoObjectType): class Meta: model = Apartment class Query(graphene.ObjectType): all_apartments = DjangoListField(ApartmentType) schema = graphene.Schema(query=Query) We could also use the optimize function to wrap a custom resolver queryset: import graphene from query_optimizer import DjangoObjectType, optimize # new import from tests.example.models import Apartment class ApartmentType(DjangoObjectType): class Meta: model = Apartment class Query(graphene.ObjectType): all_apartments = graphene.List(ApartmentType) def resolve_all_apartments(root, info): return optimize(Apartment.objects.all(), info) # wrapped function schema = graphene.Schema(query=Query) That's it! With the following configuration, the same query will result in just 3 database queries, regardless of the number of database records. 1 query for all apartments 1 query for all sales in all apartments 1 query for all ownerships with their owners for each sale in each apartment Also, the optimization will only fetch the fields given in the GraphQL query, as the query intended. See technical details on how this works.","title":"Quickstart"},{"location":"relay/","text":"Relay The optimization will also work with Relay Nodes. Nodes Let's say we have the following node in out schema: import graphene from graphene import relay from graphene_django import DjangoObjectType from tests.example.models import Apartment class ApartmentNode(DjangoObjectType): class Meta: model = Apartment filter_fields = { \"street_address\": [\"exact\"], \"building__name\": [\"exact\"], } interfaces = (relay.Node,) class Query(graphene.ObjectType): apartment = relay.Node.Field(ApartmentNode) schema = graphene.Schema(query=Query) We can optimize this query by simply using DjangoObjectType from query_optimizer . import graphene from graphene import relay from query_optimizer import DjangoObjectType # replaced import from tests.example.models import Apartment class ApartmentNode(DjangoObjectType): class Meta: model = Apartment filter_fields = { \"street_address\": [\"exact\"], \"building__name\": [\"exact\"], } interfaces = (relay.Node,) class Query(graphene.ObjectType): apartment = relay.Node.Field(ApartmentNode) schema = graphene.Schema(query=Query) That's it! Connections Given the following connection in out schema: import graphene from graphene import relay from graphene_django import DjangoObjectType, DjangoConnectionField from tests.example.models import Apartment class ApartmentNode(DjangoObjectType): class Meta: model = Apartment interfaces = (relay.Node,) class Query(graphene.ObjectType): paged_apartments = DjangoConnectionField(ApartmentNode) schema = graphene.Schema(query=Query) We can optimize this query by simply using DjangoObjectType and DjangoConnectionField from query_optimizer , like this: import graphene from graphene import relay from query_optimizer import DjangoObjectType, DjangoConnectionField # replaced import from tests.example.models import Apartment class ApartmentNode(DjangoObjectType): class Meta: model = Apartment interfaces = (relay.Node,) class Query(graphene.ObjectType): paged_apartments = DjangoConnectionField(ApartmentNode) schema = graphene.Schema(query=Query) If we want filtering, we can use: import graphene from graphene import relay from query_optimizer import DjangoObjectType # replaced import from query_optimizer.filter import DjangoFilterConnectionField # replaced import from tests.example.models import Apartment class ApartmentNode(DjangoObjectType): class Meta: model = Apartment filter_fields = { \"street_address\": [\"exact\"], \"building__name\": [\"exact\"], } interfaces = (relay.Node,) class Query(graphene.ObjectType): paged_apartments = DjangoFilterConnectionField(ApartmentNode) schema = graphene.Schema(query=Query) django-filter is required for the above to work. That's it!","title":"Relay"},{"location":"relay/#relay","text":"The optimization will also work with Relay Nodes.","title":"Relay"},{"location":"relay/#nodes","text":"Let's say we have the following node in out schema: import graphene from graphene import relay from graphene_django import DjangoObjectType from tests.example.models import Apartment class ApartmentNode(DjangoObjectType): class Meta: model = Apartment filter_fields = { \"street_address\": [\"exact\"], \"building__name\": [\"exact\"], } interfaces = (relay.Node,) class Query(graphene.ObjectType): apartment = relay.Node.Field(ApartmentNode) schema = graphene.Schema(query=Query) We can optimize this query by simply using DjangoObjectType from query_optimizer . import graphene from graphene import relay from query_optimizer import DjangoObjectType # replaced import from tests.example.models import Apartment class ApartmentNode(DjangoObjectType): class Meta: model = Apartment filter_fields = { \"street_address\": [\"exact\"], \"building__name\": [\"exact\"], } interfaces = (relay.Node,) class Query(graphene.ObjectType): apartment = relay.Node.Field(ApartmentNode) schema = graphene.Schema(query=Query) That's it!","title":"Nodes"},{"location":"relay/#connections","text":"Given the following connection in out schema: import graphene from graphene import relay from graphene_django import DjangoObjectType, DjangoConnectionField from tests.example.models import Apartment class ApartmentNode(DjangoObjectType): class Meta: model = Apartment interfaces = (relay.Node,) class Query(graphene.ObjectType): paged_apartments = DjangoConnectionField(ApartmentNode) schema = graphene.Schema(query=Query) We can optimize this query by simply using DjangoObjectType and DjangoConnectionField from query_optimizer , like this: import graphene from graphene import relay from query_optimizer import DjangoObjectType, DjangoConnectionField # replaced import from tests.example.models import Apartment class ApartmentNode(DjangoObjectType): class Meta: model = Apartment interfaces = (relay.Node,) class Query(graphene.ObjectType): paged_apartments = DjangoConnectionField(ApartmentNode) schema = graphene.Schema(query=Query) If we want filtering, we can use: import graphene from graphene import relay from query_optimizer import DjangoObjectType # replaced import from query_optimizer.filter import DjangoFilterConnectionField # replaced import from tests.example.models import Apartment class ApartmentNode(DjangoObjectType): class Meta: model = Apartment filter_fields = { \"street_address\": [\"exact\"], \"building__name\": [\"exact\"], } interfaces = (relay.Node,) class Query(graphene.ObjectType): paged_apartments = DjangoFilterConnectionField(ApartmentNode) schema = graphene.Schema(query=Query) django-filter is required for the above to work. That's it!","title":"Connections"},{"location":"settings/","text":"Settings Here are the available settings. Setting Type Default Description QUERY_CACHE_KEY str \"_query_cache\" Key to store fetched model instances under in the GraphQL schema extensions. OPTIMIZER_MARK str \"_optimized\" Key used mark if a queryset has been optimized by the query optimizer. DISABLE_ONLY_FIELDS_OPTIMIZATION str False Set to True to disable optimizing fetched fields with queryset.only() . MAX_COMPLEXITY int 10 Default max number of select_related and prefetch_related joins optimizer is allowed to optimize. Set them under the GRAPHQL_QUERY_OPTIMIZER key in your projects settings.py like this: GRAPHQL_QUERY_OPTIMIZER = { \"MAX_COMPLEXITY\": 10, }","title":"Settings"},{"location":"settings/#settings","text":"Here are the available settings. Setting Type Default Description QUERY_CACHE_KEY str \"_query_cache\" Key to store fetched model instances under in the GraphQL schema extensions. OPTIMIZER_MARK str \"_optimized\" Key used mark if a queryset has been optimized by the query optimizer. DISABLE_ONLY_FIELDS_OPTIMIZATION str False Set to True to disable optimizing fetched fields with queryset.only() . MAX_COMPLEXITY int 10 Default max number of select_related and prefetch_related joins optimizer is allowed to optimize. Set them under the GRAPHQL_QUERY_OPTIMIZER key in your projects settings.py like this: GRAPHQL_QUERY_OPTIMIZER = { \"MAX_COMPLEXITY\": 10, }","title":"Settings"},{"location":"technical/","text":"Technical details The optimizer uses the GraphQLResolveInfo and GraphQL AST to introspect the desired query, and construct queryset.only() , queryset.select_related() , and queryset.prefetch_related() statements for the resolver queryset. The queryset is then \"marked as optimized\" in the queryset hints (1) by setting a key defined by the OPTIMIZER_MARK setting. The result is then stored inside the schema extensions dictionary under a key defined by the QUERY_CACHE_KEY setting. The cache uses a WeakKeyDictionary , where the key is a info.operation for the current query. This ensures that the cache is automatically cleared after the request is done. Different records are sorted based on their database table name, selected fields & joined tables, and primary keys. Subsequent resolvers will then attempt to retrieve the cached data stored by the parent query. Queryset hints are designed to be used in multi-database routing, so this is a slightly hacky way to ensuring the mark is retained when the queryset is cloned. It is relatively safe since multi-database routers should accept the hints as **kwargs, and can ignore this extra hint.","title":"Technical Details"},{"location":"technical/#technical-details","text":"The optimizer uses the GraphQLResolveInfo and GraphQL AST to introspect the desired query, and construct queryset.only() , queryset.select_related() , and queryset.prefetch_related() statements for the resolver queryset. The queryset is then \"marked as optimized\" in the queryset hints (1) by setting a key defined by the OPTIMIZER_MARK setting. The result is then stored inside the schema extensions dictionary under a key defined by the QUERY_CACHE_KEY setting. The cache uses a WeakKeyDictionary , where the key is a info.operation for the current query. This ensures that the cache is automatically cleared after the request is done. Different records are sorted based on their database table name, selected fields & joined tables, and primary keys. Subsequent resolvers will then attempt to retrieve the cached data stored by the parent query. Queryset hints are designed to be used in multi-database routing, so this is a slightly hacky way to ensuring the mark is retained when the queryset is cloned. It is relatively safe since multi-database routers should accept the hints as **kwargs, and can ignore this extra hint.","title":"Technical details"}]}